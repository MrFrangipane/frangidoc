import os
import sys
import copy
import stat
import errno
import shutil
import logging
import tempfile
import subprocess
import generator
import git
import yaml


def _handle_remove_read_only(func, path, exc):
  excvalue = exc[1]
  if func in (os.rmdir, os.remove) and excvalue.errno == errno.EACCES:
      os.chmod(path, stat.S_IRWXU| stat.S_IRWXG| stat.S_IRWXO) # 0777
      func(path)
  else:
      raise


def generate_and_save(module_name, output_filepath=None):
    module = generator.get_module(module_name)

    if module is None: return

    if output_filepath is None:
        output_filepath = generator.make_output_filepath(module)

    content = generator.get_markdown(module)

    with open(output_filepath, "w+") as content_file:
        content_file.write(content)

    logging.info("Output file written : %s" % output_filepath)


def argparse_and_save(package_name, module_filepath, output_filepath):
    logging.info(" -> Generating Markdown for CLI '{}'".format(package_name))

    command = "python {} -h".format(module_filepath)

    try:
        content = subprocess.check_output(command, shell=True)
    except Exception, e:
        logging.warn("    Error while executing '{}' :".format(command))
        logging.warn(e)
        return

    lines = [
        '# {} : CLI'.format(package_name),
        '',
        'Here is the output generated by running `python -m {} -h` :'.format(package_name),
        '',
        '```text'
    ]

    lines += content.splitlines()
    lines.append('```')

    with open(output_filepath, 'w') as f_markdown:
        f_markdown.write('\n'.join(lines))

    logging.info("Output file written : %s" % output_filepath)


def clone_and_generate(repository_url, output_directory, cleanup=True):
    # TODO : range moi ca !
    repo_name = os.path.basename(repository_url).replace('.git', '')
    temp_folder = tempfile.mkdtemp(prefix="frangidoc-{}.".format(repo_name))
    config_filepath = os.path.join(temp_folder, '.frangidoc.yml')

    try:
        git.Repo.clone_from(repository_url, temp_folder)
    except git.GitCommandError, e:
        logging.warn("Impossible to clone {repo_url}".format(repo_url=repository_url))
        logging.warn(e)
        return False

    logging.info("Cloned {repo_url} to {temp_folder}".format(repo_url=repository_url, temp_folder=temp_folder))

    if not os.path.isfile(config_filepath):
        logging.warn("Could not find .frangidoc.yml, aborting")
        return False

    with open(config_filepath, 'r') as f_config:
        config = yaml.load(f_config)

    logging.info("Loaded .frangidoc.yml")

    output_folder = os.path.join(output_directory, config['title'])

    if os.path.isdir(output_folder):
        shutil.rmtree(output_folder, ignore_errors=False, onerror=_handle_remove_read_only)

    os.makedirs(output_folder)

    sys_path_backup = copy.deepcopy(sys.path)
    environment_backup = copy.deepcopy(os.environ)

    environment = config.get('environment', dict())
    for key, value in environment.iteritems():
        value = value.replace(':', ';')
        logging.info("Adding to {} : {}".format(key, value))

        if key.upper() == 'PYTHONPATH':
            for path in value.split(';'):
                sys.path.append(path)
        else:
            os.environ[key] = value

    sys_path_inter_backup = copy.deepcopy(sys.path)

    for module_filepath in config.get('modules', list()):
        module_fullpath = os.path.join(temp_folder, module_filepath)
        relative_path, filename = os.path.split(module_filepath)
        path = os.path.join(temp_folder, relative_path)
        package_name = os.path.basename(relative_path)
        name = filename.replace('.py', '')

        # Todo deplacer cette logique dans 'generate_and_save()' (pour que l'api soit consitante entre 'git' et 'module')
        if name == '__init__':
            name = package_name
            path = os.path.dirname(path)

        sys.path.insert(0, path)

        if name == '__main__':
            output_filename = os.path.join(output_folder, package_name + ' (CLI).md')
            argparse_and_save(package_name, module_fullpath, output_filename)

        else:
            output_filename = os.path.join(output_folder, name + '.md')
            generate_and_save(name, output_filename)

        sys.path = copy.deepcopy(sys_path_inter_backup)

    sys.path = copy.deepcopy(sys_path_backup)
    os.environ = environment_backup

    if cleanup:
        shutil.rmtree(temp_folder, ignore_errors=False, onerror=_handle_remove_read_only)

    return True
